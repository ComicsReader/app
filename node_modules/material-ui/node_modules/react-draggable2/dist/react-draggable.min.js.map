{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-draggable.min.js","webpack:///webpack/bootstrap 5b79c4adb713b64db2f5","webpack:///./lib/draggable.js","webpack:///external \"React\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","updateBoundState","state","bound","String","boundTop","indexOf","boundRight","boundBottom","boundLeft","boundAll","boundBox","createUIEvent","draggable","position","top","offsetTop","left","offsetLeft","canDragY","props","axis","canDragX","isFunction","func","Object","prototype","toString","findInArray","array","callback","i","element","length","apply","matchesSelector","el","selector","method","getControlPosition","e","touches","clientX","clientY","addEvent","event","handler","attachEvent","addEventListener","removeEvent","detachEvent","removeEventListener","bodyElement","React","emptyFunction","window","document","body","isTouchDevice","dragEventFor","eventsFor","touch","start","move","end","mouse","createClass","displayName","mixins","addons","PureRenderMixin","propTypes","PropTypes","oneOf","handle","string","cancel","grid","arrayOf","number","constrain","object","zIndex","useChild","bool","onStart","onDrag","onStop","onMouseDown","getDefaultProps","NaN","getInitialState","dragging","x","y","componentWillReceiveProps","nextProps","setState","componentWillUnmount","handleDrag","handleDragEnd","handleDragStart","target","dragPoint","className","replace","offset","boundingValue","_toPixels","node","getDOMNode","offsetParent","clientWidth","offsetWidth","clientHeight","offsetHeight","Array","isArray","constrainOffset","prev","snap","delta","Math","abs","parseInt","pos","prevLeft","prevTop","positions","isNaN","onTouchStart","preventDefault","arguments","render","style","onMouseUp","onTouchEnd","cloneWithProps","Children","only","children","DOM","div","value","slice","isFinite"],"mappings":"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","file":"react-draggable.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactDraggable\"] = factory(require(\"React\"));\n\telse\n\t\troot[\"ReactDraggable\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactDraggable\"] = factory(require(\"React\"));\n\telse\n\t\troot[\"ReactDraggable\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(1);\n\tvar emptyFunction = function () {};\n\t\n\t// for accessing browser globals\n\tvar root = typeof window !== 'undefined' ? window : this;\n\tvar bodyElement;\n\tif (typeof document !== 'undefined' && 'body' in document) {\n\t  bodyElement = document.body;\n\t}\n\t\n\tfunction updateBoundState (state, bound) {\n\t  if (!bound) return state;\n\t  bound = String(bound);\n\t  var boundTop = !!~bound.indexOf('top');\n\t  var boundRight = !!~bound.indexOf('right');\n\t  var boundBottom = !!~bound.indexOf('bottom');\n\t  var boundLeft = !!~bound.indexOf('left');\n\t  var boundAll = !!~bound.indexOf('all') ||\n\t    !(boundTop || boundRight || boundBottom || boundLeft);\n\t  var boundBox = !~bound.indexOf('point');\n\t  state.boundTop = boundAll || boundTop;\n\t  state.boundRight = boundAll || boundRight;\n\t  state.boundBottom = boundAll || boundBottom;\n\t  state.boundLeft = boundAll || boundLeft;\n\t  state.boundBox = boundBox;\n\t  return state;\n\t};\n\t\n\tfunction createUIEvent(draggable) {\n\t  return {\n\t    position: {\n\t      top: draggable.state.offsetTop,\n\t      left: draggable.state.offsetLeft\n\t    }\n\t  };\n\t}\n\t\n\tfunction canDragY(draggable) {\n\t  return draggable.props.axis === 'both' ||\n\t      draggable.props.axis === 'y';\n\t}\n\t\n\tfunction canDragX(draggable) {\n\t  return draggable.props.axis === 'both' ||\n\t      draggable.props.axis === 'x';\n\t}\n\t\n\tfunction isFunction(func) {\n\t  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]'\n\t}\n\t\n\t// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\n\tfunction findInArray(array, callback) {\n\t  for (var i = 0, length = array.length, element = null; i < length, element = array[i]; i++) {\n\t    if (callback.apply(callback, [element, i, array])) return element;\n\t  }\n\t}\n\t\n\tfunction matchesSelector(el, selector) {\n\t  var method = findInArray([\n\t    'matches',\n\t    'webkitMatchesSelector',\n\t    'mozMatchesSelector',\n\t    'msMatchesSelector',\n\t    'oMatchesSelector'\n\t  ], function(method){\n\t    return isFunction(el[method]);\n\t  });\n\t\n\t  return el[method].call(el, selector);\n\t}\n\t\n\t// @credits: http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886\n\tvar isTouchDevice = 'ontouchstart' in root // works on most browsers\n\t                 || 'onmsgesturechange' in root; // works on ie10 on ms surface\n\t\n\t// look ::handleDragStart\n\t//function isMultiTouch(e) {\n\t//  return e.touches && Array.isArray(e.touches) && e.touches.length > 1\n\t//}\n\t\n\t/**\n\t * simple abstraction for dragging events names\n\t * */\n\tvar dragEventFor = (function () {\n\t  var eventsFor = {\n\t    touch: {\n\t      start: 'touchstart',\n\t      move: 'touchmove',\n\t      end: 'touchend'\n\t    },\n\t    mouse: {\n\t      start: 'mousedown',\n\t      move: 'mousemove',\n\t      end: 'mouseup'\n\t    }\n\t  };\n\t  return eventsFor[isTouchDevice ? 'touch' : 'mouse'];\n\t})();\n\t\n\t/**\n\t * get {clientX, clientY} positions of control\n\t * */\n\tfunction getControlPosition(e) {\n\t  var position = (e.touches && e.touches[0]) || e;\n\t  return {\n\t    clientX: position.clientX,\n\t    clientY: position.clientY\n\t  }\n\t}\n\t\n\tfunction addEvent(el, event, handler) {\n\t  if (!el) { return; }\n\t  if (el.attachEvent) {\n\t    el.attachEvent('on' + event, handler);\n\t  } else if (el.addEventListener) {\n\t    el.addEventListener(event, handler, true);\n\t  } else {\n\t    el['on' + event] = handler;\n\t  }\n\t}\n\t\n\tfunction removeEvent(el, event, handler) {\n\t  if (!el) { return; }\n\t  if (el.detachEvent) {\n\t    el.detachEvent('on' + event, handler);\n\t  } else if (el.removeEventListener) {\n\t    el.removeEventListener(event, handler, true);\n\t  } else {\n\t    el['on' + event] = null;\n\t  }\n\t}\n\t\n\tmodule.exports = React.createClass({\n\t  displayName: 'Draggable',\n\t  mixins: [React.addons.PureRenderMixin],\n\t\n\t  propTypes: {\n\t    /**\n\t     * `axis` determines which axis the draggable can move.\n\t     *\n\t     * 'both' allows movement horizontally and vertically.\n\t     * 'x' limits movement to horizontal axis.\n\t     * 'y' limits movement to vertical axis.\n\t     *\n\t     * Defaults to 'both'.\n\t     */\n\t    axis: React.PropTypes.oneOf(['both', 'x', 'y']),\n\t\n\t    /**\n\t     * `handle` specifies a selector to be used as the handle that initiates drag.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *  var App = React.createClass({\n\t     *      render: function () {\n\t     *        return (\n\t     *          <Draggable handle=\".handle\">\n\t     *            <div>\n\t     *                <div className=\"handle\">Click me to drag</div>\n\t     *                <div>This is some other content</div>\n\t     *            </div>\n\t     *          </Draggable>\n\t     *        );\n\t     *      }\n\t     *  });\n\t     * ```\n\t     */\n\t    handle: React.PropTypes.string,\n\t\n\t    /**\n\t     * `cancel` specifies a selector to be used to prevent drag initialization.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *  var App = React.createClass({\n\t     *      render: function () {\n\t     *          return(\n\t     *              <Draggable cancel=\".cancel\">\n\t     *                  <div>\n\t     *                    <div className=\"cancel\">You can't drag from here</div>\n\t     *            <div>Dragging here works fine</div>\n\t     *                  </div>\n\t     *              </Draggable>\n\t     *          );\n\t     *      }\n\t     *  });\n\t     * ```\n\t     */\n\t    cancel: React.PropTypes.string,\n\t\n\t    /**\n\t     * `bound` determines whether to bound the movement to the parent box.\n\t     *\n\t     * The property takes a list of space-separated strings. The Draggable\n\t     * is bounded by the nearest DOMNode.offsetParent. To set the offset\n\t     * parent, give it a position value other than 'static'.\n\t     *\n\t     * Optionally choose one or more bounds from:\n\t     * 'top' bounds movement to the top edge of the parent box.\n\t     * 'right' bounds movement to the right edge of the parent box.\n\t     * 'bottom' bounds movement to the bottom edge of the parent box.\n\t     * 'left' bounds movement to the left edge of the parent box.\n\t     * 'all' bounds movement to all edges (default if not specified).\n\t     *\n\t     * Optionally choose one anchor from:\n\t     * 'point' to constrain only the top-left corner.\n\t     * 'box' to constrain the entire box (default if not specified).\n\t     *\n\t     * You may use more than one bound, e.g. 'top left point'. Set to a\n\t     * falsy value to disable.\n\t     *\n\t     * Defaults to 'all box'.\n\t     */\n\t    bound: React.PropTypes.string,\n\t\n\t    /**\n\t     * `grid` specifies the x and y that dragging should snap to.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *   var App = React.createClass({\n\t     *       render: function () {\n\t     *           return (\n\t     *              <Draggable grid={[25, 25]}>\n\t     *                   <div>I snap to a 25 x 25 grid</div>\n\t     *               </Draggable>\n\t     *           );\n\t     *      }\n\t     *   });\n\t     * ```\n\t     */\n\t    grid: React.PropTypes.arrayOf(React.PropTypes.number),\n\t\n\t    /**\n\t     * `constrain` takes a function to constrain the dragging.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *   function constrain (snap) {\n\t     *         function constrainOffset (offset, prev) {\n\t     *               var delta = offset - prev;\n\t     *               if (Math.abs(delta) >= snap) {\n\t     *                     return prev + (delta < 0 ? -snap : snap);\n\t     *               }\n\t     *               return prev;\n\t     *         }\n\t     *         return function (pos) {\n\t     *               return {\n\t     *                     top: constrainOffset(pos.top, pos.prevTop),\n\t     *                     left: constrainOffset(pos.left, pos.prevLeft)\n\t     *               };\n\t     *         };\n\t     *   }\n\t     *   var App = React.createClass({\n\t     *       render: function () {\n\t     *           return (\n\t     *               <Draggable constrain={constrain}>\n\t     *                   <div>I snap to a 25 x 25 grid</div>\n\t     *               </Draggable>\n\t     *           );\n\t     *       }\n\t     *   });\n\t     * ```\n\t     */\n\t    constrain: React.PropTypes.func,\n\t\n\t    /**\n\t     * `start` specifies the x and y that the dragged item should start at\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *  var App = React.createClass({\n\t     *      render: function () {\n\t     *          return (\n\t     *              <Draggable start={{x: 25, y: 25}}>\n\t     *                  <div>I start with left: 25px; top: 25px;</div>\n\t     *              </Draggable>\n\t     *          );\n\t     *      }\n\t     *  });\n\t     * ```\n\t     */\n\t    start: React.PropTypes.object,\n\t\n\t    /**\n\t     * `zIndex` specifies the zIndex to use while dragging.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```jsx\n\t     *  var App = React.createClass({\n\t     *      render: function () {\n\t     *          return (\n\t     *              <Draggable zIndex={100}>\n\t     *                  <div>I have a zIndex</div>\n\t     *              </Draggable>\n\t     *          );\n\t     *      }\n\t     *  });\n\t     * ```\n\t     */\n\t    zIndex: React.PropTypes.number,\n\t\n\t    /**\n\t     * `useChild` determines whether to use the first child as root.\n\t     *\n\t     * If false, a div is created. This option is required if any children\n\t     * have a ref.\n\t     *\n\t     * Defaults to true.\n\t     */\n\t    useChild: React.PropTypes.bool,\n\t\n\t    /**\n\t     * Called when dragging starts.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```js\n\t     *  function (event, ui) {}\n\t     * ```\n\t     *\n\t     * `event` is the Event that was triggered.\n\t     * `ui` is an object:\n\t     *\n\t     * ```js\n\t     *  {\n\t     *    position: {top: 0, left: 0}\n\t     *  }\n\t     * ```\n\t     */\n\t    onStart: React.PropTypes.func,\n\t\n\t    /**\n\t     * Called while dragging.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```js\n\t     *  function (event, ui) {}\n\t     * ```\n\t     *\n\t     * `event` is the Event that was triggered.\n\t     * `ui` is an object:\n\t     *\n\t     * ```js\n\t     *  {\n\t     *    position: {top: 0, left: 0}\n\t     *  }\n\t     * ```\n\t     */\n\t    onDrag: React.PropTypes.func,\n\t\n\t    /**\n\t     * Called when dragging stops.\n\t     *\n\t     * Example:\n\t     *\n\t     * ```js\n\t     *  function (event, ui) {}\n\t     * ```\n\t     *\n\t     * `event` is the Event that was triggered.\n\t     * `ui` is an object:\n\t     *\n\t     * ```js\n\t     *  {\n\t     *    position: {top: 0, left: 0}\n\t     *  }\n\t     * ```\n\t     */\n\t    onStop: React.PropTypes.func,\n\t\n\t    /**\n\t     * A workaround option which can be passed if onMouseDown needs to be accessed, since it'll always be blocked (due to that there's internal use of onMouseDown)\n\t     *\n\t     */\n\t    onMouseDown: React.PropTypes.func\n\t  },\n\t\n\t  getDefaultProps: function () {\n\t    return {\n\t      axis: 'both',\n\t      bound: null,\n\t      handle: null,\n\t      cancel: null,\n\t      grid: null,\n\t      start: {},\n\t      zIndex: NaN,\n\t      useChild: true,\n\t      onStart: emptyFunction,\n\t      onDrag: emptyFunction,\n\t      onStop: emptyFunction,\n\t      onMouseDown: emptyFunction\n\t    };\n\t  },\n\t\n\t  getInitialState: function () {\n\t    var state = {\n\t      // Whether or not currently dragging\n\t      dragging: false,\n\t\n\t      // Pointer offset on screen\n\t      clientX: 0, clientY: 0,\n\t\n\t      // DOMNode offset relative to parent\n\t      offsetLeft: this.props.start.x || 0, offsetTop: this.props.start.y || 0\n\t    };\n\t\n\t    updateBoundState(state, this.props.bound);\n\t\n\t    return state;\n\t  },\n\t\n\t  componentWillReceiveProps: function (nextProps) {\n\t    var state = updateBoundState({}, nextProps.bound);\n\t    if (nextProps.start) {\n\t      if (nextProps.start.x != null) {\n\t        state.offsetLeft = nextProps.start.x || 0;\n\t      }\n\t      if (nextProps.start.y != null) {\n\t        state.offsetTop = nextProps.start.y || 0;\n\t      }\n\t    }\n\t    this.setState(state);\n\t  },\n\t\n\t  componentWillUnmount: function() {\n\t    // Remove any leftover event handlers\n\t    removeEvent(root, dragEventFor['move'], this.handleDrag);\n\t    removeEvent(root, dragEventFor['end'], this.handleDragEnd);\n\t  },\n\t\n\t  handleDragStart: function (e) {\n\t    // todo: write right implementation to prevent multitouch drag\n\t    // prevent multi-touch events\n\t    // if (isMultiTouch(e)) {\n\t    //     this.handleDragEnd.apply(e, arguments);\n\t    //     return\n\t    // }\n\t\n\t    // Make it possible to attach event handlers on top of this one\n\t    this.props.onMouseDown(e);\n\t\n\t    // Short circuit if handle or cancel prop was provided and selector doesn't match\n\t    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||\n\t      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {\n\t      return;\n\t    }\n\t\n\t    var dragPoint = getControlPosition(e);\n\t\n\t    // Initiate dragging\n\t    this.setState({\n\t      dragging: true,\n\t      clientX: dragPoint.clientX,\n\t      clientY: dragPoint.clientY\n\t    });\n\t\n\t    // Call event handler\n\t    this.props.onStart(e, createUIEvent(this));\n\t\n\t    // Add event handlers\n\t    addEvent(root, dragEventFor['move'], this.handleDrag);\n\t    addEvent(root, dragEventFor['end'], this.handleDragEnd);\n\t\n\t    // Add dragging class to body element\n\t    if (bodyElement) bodyElement.className += ' react-draggable-dragging';\n\t  },\n\t\n\t  handleDragEnd: function (e) {\n\t    // Short circuit if not currently dragging\n\t    if (!this.state.dragging) {\n\t      return;\n\t    }\n\t\n\t    // Turn off dragging\n\t    this.setState({\n\t      dragging: false\n\t    });\n\t\n\t    // Call event handler\n\t    this.props.onStop(e, createUIEvent(this));\n\t\n\t    // Remove event handlers\n\t    removeEvent(root, dragEventFor['move'], this.handleDrag);\n\t    removeEvent(root, dragEventFor['end'], this.handleDragEnd);\n\t\n\t    // Remove dragging class from body element\n\t    if (bodyElement) {\n\t      var className = bodyElement.className;\n\t      bodyElement.className =\n\t        className.replace(/(?:^|\\s+)react-draggable-dragging\\b/, ' ');\n\t    }\n\t  },\n\t\n\t  handleDrag: function (e) {\n\t    var dragPoint = getControlPosition(e);\n\t    var offsetLeft = this._toPixels(this.state.offsetLeft);\n\t    var offsetTop = this._toPixels(this.state.offsetTop);\n\t\n\t    var state = {\n\t      offsetLeft: offsetLeft,\n\t      offsetTop: offsetTop\n\t    };\n\t\n\t    // Get parent DOM node\n\t    var node = this.getDOMNode();\n\t    var offsetParent = node.offsetParent;\n\t    var offset, boundingValue;\n\t\n\t    if (canDragX(this)) {\n\t      // Calculate updated position\n\t      offset = offsetLeft + dragPoint.clientX - this.state.clientX;\n\t\n\t      // Bound movement to parent box\n\t      if (this.state.boundLeft) {\n\t        boundingValue = state.offsetLeft - node.offsetLeft;\n\t        if (offset < boundingValue) {\n\t          offset = boundingValue;\n\t        }\n\t      }\n\t      if (this.state.boundRight) {\n\t        boundingValue += offsetParent.clientWidth;\n\t        if (this.state.boundBox) {\n\t          boundingValue -= node.offsetWidth;\n\t        }\n\t        if (offset > boundingValue) {\n\t          offset = boundingValue;\n\t        }\n\t      }\n\t      // Update left\n\t      state.offsetLeft = offset;\n\t    }\n\t\n\t    if (canDragY(this)) {\n\t      // Calculate updated position\n\t      offset = offsetTop + dragPoint.clientY - this.state.clientY;\n\t      // Bound movement to parent box\n\t      if (this.state.boundTop) {\n\t        boundingValue = state.offsetTop - node.offsetTop;\n\t        if (offset < boundingValue) {\n\t          offset = boundingValue;\n\t        }\n\t      }\n\t      if (this.state.boundBottom) {\n\t        boundingValue += offsetParent.clientHeight;\n\t        if (this.state.boundBox) {\n\t          boundingValue -= node.offsetHeight;\n\t        }\n\t        if (offset > boundingValue) {\n\t          offset = boundingValue;\n\t        }\n\t      }\n\t      // Update top\n\t      state.offsetTop = offset;\n\t    }\n\t\n\t    var constrain = this.props.constrain;\n\t    var grid = this.props.grid;\n\t\n\t    // Backwards-compatibility for snap to grid\n\t    if (!constrain && Array.isArray(grid)) {\n\t      var constrainOffset = function (offset, prev, snap) {\n\t        var delta = offset - prev;\n\t        if (Math.abs(delta) >= snap) {\n\t          return prev + parseInt(delta / snap, 10) * snap;\n\t        }\n\t        return prev;\n\t      };\n\t      constrain = function (pos) {\n\t        return {\n\t          left: constrainOffset(pos.left, pos.prevLeft, grid[0]),\n\t          top: constrainOffset(pos.top, pos.prevTop, grid[1])\n\t        };\n\t      };\n\t    }\n\t\n\t    // Constrain if function has been provided\n\t    var positions;\n\t    if (constrain) {\n\t      // Constrain positions\n\t      positions = constrain({\n\t        prevLeft: this.state.offsetLeft,\n\t        prevTop: this.state.offsetTop,\n\t        left: state.offsetLeft,\n\t        top: state.offsetTop\n\t      });\n\t      if (positions) {\n\t        // Update left\n\t        if ('left' in positions && !isNaN(positions.left)) {\n\t          state.offsetLeft = positions.left;\n\t        }\n\t        // Update top\n\t        if ('top' in positions && !isNaN(positions.top)) {\n\t          state.offsetTop = positions.top;\n\t        }\n\t      }\n\t    }\n\t\n\t    // Save new state\n\t    state.clientX = this.state.clientX + (state.offsetLeft - offsetLeft);\n\t    state.clientY = this.state.clientY + (state.offsetTop - offsetTop);\n\t    this.setState(state);\n\t\n\t    // Call event handler\n\t    this.props.onDrag(e, createUIEvent(this));\n\t  },\n\t\n\t  onTouchStart: function (e) {\n\t    e.preventDefault(); // prevent for scroll\n\t    return this.handleDragStart.apply(this, arguments);\n\t  },\n\t\n\t  render: function () {\n\t    var style = {\n\t      top: this.state.offsetTop,\n\t      left: this.state.offsetLeft\n\t    };\n\t\n\t    // Set zIndex if currently dragging and prop has been provided\n\t    if (this.state.dragging && !isNaN(this.props.zIndex)) {\n\t      style.zIndex = this.props.zIndex;\n\t    }\n\t\n\t    var props = {\n\t      style: style,\n\t      className: 'react-draggable',\n\t\n\t      onMouseDown: this.handleDragStart,\n\t      onTouchStart: this.onTouchStart,\n\t\n\t      onMouseUp: this.handleDragEnd,\n\t      onTouchEnd: this.handleDragEnd\n\t    };\n\t\n\t    // Reuse the child provided\n\t    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n\t    if (this.props.useChild) {\n\t      return React.addons.cloneWithProps(React.Children.only(this.props.children), props);\n\t    }\n\t\n\t    return React.DOM.div(props, this.props.children);\n\t  },\n\t\n\t  _toPixels: function (value) {\n\t\n\t    // Support percentages\n\t    if (typeof value == 'string' && value.slice(-1) == '%') {\n\t      return parseInt((+value.replace('%', '') / 100) *\n\t        this.getDOMNode().offsetParent.clientWidth, 10) || 0;\n\t    }\n\t\n\t    // Invalid values become zero\n\t    var i = parseInt(value, 10);\n\t    if (isNaN(i) || !isFinite(i)) return 0;\n\t\n\t    return i;\n\t  }\n\t\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** react-draggable.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5b79c4adb713b64db2f5\n **/","'use strict';\n\nvar React = require('react/addons');\nvar emptyFunction = function () {};\n\n// for accessing browser globals\nvar root = typeof window !== 'undefined' ? window : this;\nvar bodyElement;\nif (typeof document !== 'undefined' && 'body' in document) {\n  bodyElement = document.body;\n}\n\nfunction updateBoundState (state, bound) {\n  if (!bound) return state;\n  bound = String(bound);\n  var boundTop = !!~bound.indexOf('top');\n  var boundRight = !!~bound.indexOf('right');\n  var boundBottom = !!~bound.indexOf('bottom');\n  var boundLeft = !!~bound.indexOf('left');\n  var boundAll = !!~bound.indexOf('all') ||\n    !(boundTop || boundRight || boundBottom || boundLeft);\n  var boundBox = !~bound.indexOf('point');\n  state.boundTop = boundAll || boundTop;\n  state.boundRight = boundAll || boundRight;\n  state.boundBottom = boundAll || boundBottom;\n  state.boundLeft = boundAll || boundLeft;\n  state.boundBox = boundBox;\n  return state;\n};\n\nfunction createUIEvent(draggable) {\n  return {\n    position: {\n      top: draggable.state.offsetTop,\n      left: draggable.state.offsetLeft\n    }\n  };\n}\n\nfunction canDragY(draggable) {\n  return draggable.props.axis === 'both' ||\n      draggable.props.axis === 'y';\n}\n\nfunction canDragX(draggable) {\n  return draggable.props.axis === 'both' ||\n      draggable.props.axis === 'x';\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]'\n}\n\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array, callback) {\n  for (var i = 0, length = array.length, element = null; i < length, element = array[i]; i++) {\n    if (callback.apply(callback, [element, i, array])) return element;\n  }\n}\n\nfunction matchesSelector(el, selector) {\n  var method = findInArray([\n    'matches',\n    'webkitMatchesSelector',\n    'mozMatchesSelector',\n    'msMatchesSelector',\n    'oMatchesSelector'\n  ], function(method){\n    return isFunction(el[method]);\n  });\n\n  return el[method].call(el, selector);\n}\n\n// @credits: http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886\nvar isTouchDevice = 'ontouchstart' in root // works on most browsers\n                 || 'onmsgesturechange' in root; // works on ie10 on ms surface\n\n// look ::handleDragStart\n//function isMultiTouch(e) {\n//  return e.touches && Array.isArray(e.touches) && e.touches.length > 1\n//}\n\n/**\n * simple abstraction for dragging events names\n * */\nvar dragEventFor = (function () {\n  var eventsFor = {\n    touch: {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend'\n    },\n    mouse: {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    }\n  };\n  return eventsFor[isTouchDevice ? 'touch' : 'mouse'];\n})();\n\n/**\n * get {clientX, clientY} positions of control\n * */\nfunction getControlPosition(e) {\n  var position = (e.touches && e.touches[0]) || e;\n  return {\n    clientX: position.clientX,\n    clientY: position.clientY\n  }\n}\n\nfunction addEvent(el, event, handler) {\n  if (!el) { return; }\n  if (el.attachEvent) {\n    el.attachEvent('on' + event, handler);\n  } else if (el.addEventListener) {\n    el.addEventListener(event, handler, true);\n  } else {\n    el['on' + event] = handler;\n  }\n}\n\nfunction removeEvent(el, event, handler) {\n  if (!el) { return; }\n  if (el.detachEvent) {\n    el.detachEvent('on' + event, handler);\n  } else if (el.removeEventListener) {\n    el.removeEventListener(event, handler, true);\n  } else {\n    el['on' + event] = null;\n  }\n}\n\nmodule.exports = React.createClass({\n  displayName: 'Draggable',\n  mixins: [React.addons.PureRenderMixin],\n\n  propTypes: {\n    /**\n     * `axis` determines which axis the draggable can move.\n     *\n     * 'both' allows movement horizontally and vertically.\n     * 'x' limits movement to horizontal axis.\n     * 'y' limits movement to vertical axis.\n     *\n     * Defaults to 'both'.\n     */\n    axis: React.PropTypes.oneOf(['both', 'x', 'y']),\n\n    /**\n     * `handle` specifies a selector to be used as the handle that initiates drag.\n     *\n     * Example:\n     *\n     * ```jsx\n     *  var App = React.createClass({\n     *      render: function () {\n     *        return (\n     *          <Draggable handle=\".handle\">\n     *            <div>\n     *                <div className=\"handle\">Click me to drag</div>\n     *                <div>This is some other content</div>\n     *            </div>\n     *          </Draggable>\n     *        );\n     *      }\n     *  });\n     * ```\n     */\n    handle: React.PropTypes.string,\n\n    /**\n     * `cancel` specifies a selector to be used to prevent drag initialization.\n     *\n     * Example:\n     *\n     * ```jsx\n     *  var App = React.createClass({\n     *      render: function () {\n     *          return(\n     *              <Draggable cancel=\".cancel\">\n     *                  <div>\n     *                    <div className=\"cancel\">You can't drag from here</div>\n     *            <div>Dragging here works fine</div>\n     *                  </div>\n     *              </Draggable>\n     *          );\n     *      }\n     *  });\n     * ```\n     */\n    cancel: React.PropTypes.string,\n\n    /**\n     * `bound` determines whether to bound the movement to the parent box.\n     *\n     * The property takes a list of space-separated strings. The Draggable\n     * is bounded by the nearest DOMNode.offsetParent. To set the offset\n     * parent, give it a position value other than 'static'.\n     *\n     * Optionally choose one or more bounds from:\n     * 'top' bounds movement to the top edge of the parent box.\n     * 'right' bounds movement to the right edge of the parent box.\n     * 'bottom' bounds movement to the bottom edge of the parent box.\n     * 'left' bounds movement to the left edge of the parent box.\n     * 'all' bounds movement to all edges (default if not specified).\n     *\n     * Optionally choose one anchor from:\n     * 'point' to constrain only the top-left corner.\n     * 'box' to constrain the entire box (default if not specified).\n     *\n     * You may use more than one bound, e.g. 'top left point'. Set to a\n     * falsy value to disable.\n     *\n     * Defaults to 'all box'.\n     */\n    bound: React.PropTypes.string,\n\n    /**\n     * `grid` specifies the x and y that dragging should snap to.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *           return (\n     *              <Draggable grid={[25, 25]}>\n     *                   <div>I snap to a 25 x 25 grid</div>\n     *               </Draggable>\n     *           );\n     *      }\n     *   });\n     * ```\n     */\n    grid: React.PropTypes.arrayOf(React.PropTypes.number),\n\n    /**\n     * `constrain` takes a function to constrain the dragging.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   function constrain (snap) {\n     *         function constrainOffset (offset, prev) {\n     *               var delta = offset - prev;\n     *               if (Math.abs(delta) >= snap) {\n     *                     return prev + (delta < 0 ? -snap : snap);\n     *               }\n     *               return prev;\n     *         }\n     *         return function (pos) {\n     *               return {\n     *                     top: constrainOffset(pos.top, pos.prevTop),\n     *                     left: constrainOffset(pos.left, pos.prevLeft)\n     *               };\n     *         };\n     *   }\n     *   var App = React.createClass({\n     *       render: function () {\n     *           return (\n     *               <Draggable constrain={constrain}>\n     *                   <div>I snap to a 25 x 25 grid</div>\n     *               </Draggable>\n     *           );\n     *       }\n     *   });\n     * ```\n     */\n    constrain: React.PropTypes.func,\n\n    /**\n     * `start` specifies the x and y that the dragged item should start at\n     *\n     * Example:\n     *\n     * ```jsx\n     *  var App = React.createClass({\n     *      render: function () {\n     *          return (\n     *              <Draggable start={{x: 25, y: 25}}>\n     *                  <div>I start with left: 25px; top: 25px;</div>\n     *              </Draggable>\n     *          );\n     *      }\n     *  });\n     * ```\n     */\n    start: React.PropTypes.object,\n\n    /**\n     * `zIndex` specifies the zIndex to use while dragging.\n     *\n     * Example:\n     *\n     * ```jsx\n     *  var App = React.createClass({\n     *      render: function () {\n     *          return (\n     *              <Draggable zIndex={100}>\n     *                  <div>I have a zIndex</div>\n     *              </Draggable>\n     *          );\n     *      }\n     *  });\n     * ```\n     */\n    zIndex: React.PropTypes.number,\n\n    /**\n     * `useChild` determines whether to use the first child as root.\n     *\n     * If false, a div is created. This option is required if any children\n     * have a ref.\n     *\n     * Defaults to true.\n     */\n    useChild: React.PropTypes.bool,\n\n    /**\n     * Called when dragging starts.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onStart: React.PropTypes.func,\n\n    /**\n     * Called while dragging.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onDrag: React.PropTypes.func,\n\n    /**\n     * Called when dragging stops.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onStop: React.PropTypes.func,\n\n    /**\n     * A workaround option which can be passed if onMouseDown needs to be accessed, since it'll always be blocked (due to that there's internal use of onMouseDown)\n     *\n     */\n    onMouseDown: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      axis: 'both',\n      bound: null,\n      handle: null,\n      cancel: null,\n      grid: null,\n      start: {},\n      zIndex: NaN,\n      useChild: true,\n      onStart: emptyFunction,\n      onDrag: emptyFunction,\n      onStop: emptyFunction,\n      onMouseDown: emptyFunction\n    };\n  },\n\n  getInitialState: function () {\n    var state = {\n      // Whether or not currently dragging\n      dragging: false,\n\n      // Pointer offset on screen\n      clientX: 0, clientY: 0,\n\n      // DOMNode offset relative to parent\n      offsetLeft: this.props.start.x || 0, offsetTop: this.props.start.y || 0\n    };\n\n    updateBoundState(state, this.props.bound);\n\n    return state;\n  },\n\n  componentWillReceiveProps: function (nextProps) {\n    var state = updateBoundState({}, nextProps.bound);\n    if (nextProps.start) {\n      if (nextProps.start.x != null) {\n        state.offsetLeft = nextProps.start.x || 0;\n      }\n      if (nextProps.start.y != null) {\n        state.offsetTop = nextProps.start.y || 0;\n      }\n    }\n    this.setState(state);\n  },\n\n  componentWillUnmount: function() {\n    // Remove any leftover event handlers\n    removeEvent(root, dragEventFor['move'], this.handleDrag);\n    removeEvent(root, dragEventFor['end'], this.handleDragEnd);\n  },\n\n  handleDragStart: function (e) {\n    // todo: write right implementation to prevent multitouch drag\n    // prevent multi-touch events\n    // if (isMultiTouch(e)) {\n    //     this.handleDragEnd.apply(e, arguments);\n    //     return\n    // }\n\n    // Make it possible to attach event handlers on top of this one\n    this.props.onMouseDown(e);\n\n    // Short circuit if handle or cancel prop was provided and selector doesn't match\n    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||\n      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {\n      return;\n    }\n\n    var dragPoint = getControlPosition(e);\n\n    // Initiate dragging\n    this.setState({\n      dragging: true,\n      clientX: dragPoint.clientX,\n      clientY: dragPoint.clientY\n    });\n\n    // Call event handler\n    this.props.onStart(e, createUIEvent(this));\n\n    // Add event handlers\n    addEvent(root, dragEventFor['move'], this.handleDrag);\n    addEvent(root, dragEventFor['end'], this.handleDragEnd);\n\n    // Add dragging class to body element\n    if (bodyElement) bodyElement.className += ' react-draggable-dragging';\n  },\n\n  handleDragEnd: function (e) {\n    // Short circuit if not currently dragging\n    if (!this.state.dragging) {\n      return;\n    }\n\n    // Turn off dragging\n    this.setState({\n      dragging: false\n    });\n\n    // Call event handler\n    this.props.onStop(e, createUIEvent(this));\n\n    // Remove event handlers\n    removeEvent(root, dragEventFor['move'], this.handleDrag);\n    removeEvent(root, dragEventFor['end'], this.handleDragEnd);\n\n    // Remove dragging class from body element\n    if (bodyElement) {\n      var className = bodyElement.className;\n      bodyElement.className =\n        className.replace(/(?:^|\\s+)react-draggable-dragging\\b/, ' ');\n    }\n  },\n\n  handleDrag: function (e) {\n    var dragPoint = getControlPosition(e);\n    var offsetLeft = this._toPixels(this.state.offsetLeft);\n    var offsetTop = this._toPixels(this.state.offsetTop);\n\n    var state = {\n      offsetLeft: offsetLeft,\n      offsetTop: offsetTop\n    };\n\n    // Get parent DOM node\n    var node = this.getDOMNode();\n    var offsetParent = node.offsetParent;\n    var offset, boundingValue;\n\n    if (canDragX(this)) {\n      // Calculate updated position\n      offset = offsetLeft + dragPoint.clientX - this.state.clientX;\n\n      // Bound movement to parent box\n      if (this.state.boundLeft) {\n        boundingValue = state.offsetLeft - node.offsetLeft;\n        if (offset < boundingValue) {\n          offset = boundingValue;\n        }\n      }\n      if (this.state.boundRight) {\n        boundingValue += offsetParent.clientWidth;\n        if (this.state.boundBox) {\n          boundingValue -= node.offsetWidth;\n        }\n        if (offset > boundingValue) {\n          offset = boundingValue;\n        }\n      }\n      // Update left\n      state.offsetLeft = offset;\n    }\n\n    if (canDragY(this)) {\n      // Calculate updated position\n      offset = offsetTop + dragPoint.clientY - this.state.clientY;\n      // Bound movement to parent box\n      if (this.state.boundTop) {\n        boundingValue = state.offsetTop - node.offsetTop;\n        if (offset < boundingValue) {\n          offset = boundingValue;\n        }\n      }\n      if (this.state.boundBottom) {\n        boundingValue += offsetParent.clientHeight;\n        if (this.state.boundBox) {\n          boundingValue -= node.offsetHeight;\n        }\n        if (offset > boundingValue) {\n          offset = boundingValue;\n        }\n      }\n      // Update top\n      state.offsetTop = offset;\n    }\n\n    var constrain = this.props.constrain;\n    var grid = this.props.grid;\n\n    // Backwards-compatibility for snap to grid\n    if (!constrain && Array.isArray(grid)) {\n      var constrainOffset = function (offset, prev, snap) {\n        var delta = offset - prev;\n        if (Math.abs(delta) >= snap) {\n          return prev + parseInt(delta / snap, 10) * snap;\n        }\n        return prev;\n      };\n      constrain = function (pos) {\n        return {\n          left: constrainOffset(pos.left, pos.prevLeft, grid[0]),\n          top: constrainOffset(pos.top, pos.prevTop, grid[1])\n        };\n      };\n    }\n\n    // Constrain if function has been provided\n    var positions;\n    if (constrain) {\n      // Constrain positions\n      positions = constrain({\n        prevLeft: this.state.offsetLeft,\n        prevTop: this.state.offsetTop,\n        left: state.offsetLeft,\n        top: state.offsetTop\n      });\n      if (positions) {\n        // Update left\n        if ('left' in positions && !isNaN(positions.left)) {\n          state.offsetLeft = positions.left;\n        }\n        // Update top\n        if ('top' in positions && !isNaN(positions.top)) {\n          state.offsetTop = positions.top;\n        }\n      }\n    }\n\n    // Save new state\n    state.clientX = this.state.clientX + (state.offsetLeft - offsetLeft);\n    state.clientY = this.state.clientY + (state.offsetTop - offsetTop);\n    this.setState(state);\n\n    // Call event handler\n    this.props.onDrag(e, createUIEvent(this));\n  },\n\n  onTouchStart: function (e) {\n    e.preventDefault(); // prevent for scroll\n    return this.handleDragStart.apply(this, arguments);\n  },\n\n  render: function () {\n    var style = {\n      top: this.state.offsetTop,\n      left: this.state.offsetLeft\n    };\n\n    // Set zIndex if currently dragging and prop has been provided\n    if (this.state.dragging && !isNaN(this.props.zIndex)) {\n      style.zIndex = this.props.zIndex;\n    }\n\n    var props = {\n      style: style,\n      className: 'react-draggable',\n\n      onMouseDown: this.handleDragStart,\n      onTouchStart: this.onTouchStart,\n\n      onMouseUp: this.handleDragEnd,\n      onTouchEnd: this.handleDragEnd\n    };\n\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    if (this.props.useChild) {\n      return React.addons.cloneWithProps(React.Children.only(this.props.children), props);\n    }\n\n    return React.DOM.div(props, this.props.children);\n  },\n\n  _toPixels: function (value) {\n\n    // Support percentages\n    if (typeof value == 'string' && value.slice(-1) == '%') {\n      return parseInt((+value.replace('%', '') / 100) *\n        this.getDOMNode().offsetParent.clientWidth, 10) || 0;\n    }\n\n    // Invalid values become zero\n    var i = parseInt(value, 10);\n    if (isNaN(i) || !isFinite(i)) return 0;\n\n    return i;\n  }\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/draggable.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"React\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}